{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// },
	"include statement c++": {
		"prefix": "in",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"int main(){",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    $0",
			"    return 0;",
			"}"
		],
		"description": ""
	},
	"multiply string and int": {
		"prefix": "strandint",
		"body": [
			" ",
			"string multiplySingleDigit(string& s, int x) {",
			"    reverse(s.begin(), s.end());",
			"    int n = s.size();",
			"    int carry = 0;",
			"    string ans = \"\";",
			"    ",
			"    for (int i = 0; i < n; i++) {",
			"        int temp = (s[i] - '0') * x + carry;",
			"        char ch = (temp % 10) + '0';",
			"        carry = temp / 10;",
			"        ans.push_back(ch);",
			"    }",
			"    ",
			"    if (carry != 0) ans.push_back(carry + '0');",
			"    ",
			"    reverse(s.begin(), s.end());",
			"    reverse(ans.begin(), ans.end());",
			"    return ans;",
			"}",
			" ",
			"void addStrings(string &ans, string &temp) {",
			"    reverse(ans.begin(), ans.end());",
			"    reverse(temp.begin(), temp.end());",
			"    ",
			"    int n1 = ans.size();",
			"    int n2 = temp.size();",
			"    int carry = 0, i = 0;",
			"    ",
			"    while (i < n1 || i < n2 || carry) {",
			"        int x = carry;",
			"        if (i < n1) x += (ans[i] - '0');",
			"        if (i < n2) x += (temp[i] - '0');",
			"        ",
			"        if (i < n1) ans[i] = (x % 10) + '0';",
			"        else ans.push_back((x % 10) + '0');",
			"        ",
			"        carry = x / 10;",
			"        i++;",
			"    }",
			"    ",
			"    reverse(ans.begin(), ans.end());",
			"}",
			" ",
			"string multiply(string s, int n) {",
			"    string ans = \"0\";",
			"    string currentString = s;",
			"    ",
			"    while (n > 0) {",
			"        int x = n % 10;",
			"        string temp = multiplySingleDigit(currentString, x);",
			"        addStrings(ans, temp);",
			"        ",
			"        currentString.push_back('0');",
			"        n /= 10;",
			"    }",
			"    ",
			"    return ans;",
			"}"
		],
		"description": ""
	},
	"quick sort": {
		"prefix": "quick",
		"body": [
			"int partition(vector<int>&arr,int start,int end){",
			"    int pivot=arr[start];",
			"    int p=start+1;",
			"    int q=end;",
			"    while(p<=q){",
			"        while(p<=end && arr[p]<=pivot)p++;",
			"        while(q>=start && arr[q]>=pivot)q--;",
			"        if(p<q)swap(arr[p],arr[q]);",
			"    }",
			"    if(q>start)",
			"    {",
			"        swap(arr[q],arr[start]);",
			"        return q;",
			"    }",
			"    return start;",
			"}",
			"void f(vector<int>&arr,int start,int end){",
			"    if(start>=end)return;",
			"",
			"    int pivot=partition(arr,start,end);",
			"    f(arr,start,pivot-1);",
			"    f(arr,pivot+1,end);",
			"    return;",
			"}"
		],
		"description": "quick sort"
	},
	"codeforces": {
		"prefix": "qa",
		"body": [
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC optimize(\"O3,unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			"#include \"bits/stdc++.h\"",
			"#define int long long",
			"#define uint unsigned long long",
			"#define vi vector<int>",
			"#define vvi vector<vi>",
			"#define vb vector<bool>",
			"#define vvb vector<vb>",
			"#define nl cout << \"\\n\"",
			"#define dbg(var) cout << var << \"\\n\"",
			"#define all(v) v.begin(), v.end()",
			"#define srt(v) sort(v.begin(), v.end())                                 // sort",
			"#define mxe(v) *max_element(v.begin(), v.end())                         // find max element in vector",
			"#define mne(v) *min_element(v.begin(), v.end())                         // find min element in vector",
			"#define lowerbound(v, x) lower_bound(v.begin(), v.end(), x) - v.begin() // returns index of first element >= x",
			"#define upperbound(v, x) upper_bound(v.begin(), v.end(), x) - v.begin() // returns index of first element > x",
			"#define unq(v) v.resize(distance(v.begin(), unique(v.begin(), v.end())));",
			"#define MOD 1000000007",
			"#define BASE 31",
			"// make sure to sort before applying unique // else only consecutive duplicates would be removed",
			"#define bin(x, y) bitset<y>(x)",
			"using namespace std;",
			"int modadd(int a, int b, int mod = MOD){int ans = ((a % mod) + (b % mod)) % mod;        return ans;}",
			"int modsub(int a, int b, int mod = MOD){int ans = ((a % mod) - (b % mod) + mod) % mod;  return ans;}",
			"int modmul(int a, int b, int mod = MOD){int ans = ((a % mod) * (b % mod)) % mod;        return ans;}",
			"// ================================== take ip/op like vector,pairs directly!==================================",
			"void solve(){",
			"    ",
			"    return;",
			"}",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"",
			"    int T = 1;",
			"    cin >> T;",
			"    while (T--)",
			"    {",
			"        solve();",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "codeforces"
	},
	"modulo exponentiation": {
		"prefix": "modexpo",
		"body": [
			"int modExpo(int a, int b, int mod) {",
			"    int result = 1;",
			"    a = a % mod;",
			"    while (b > 0) {",
			"        if (b & 1) {",
			"            modmul(result, a,mod);",
			"        }",
			"        modmul(a, a,mod);",
			"        b = b >> 1;",
			"    }",
			"    return result;",
			"}",
			""
		],
		"description": "modulo exponentiation"
	},
	"lps kmp": {
		"prefix": "lps",
		"body": [
			"int lps(string str)",
			"{",
			"    int n = str.size();",
			"    vector<int> dp(n, 0);",
			"    int i = 0;",
			"    for (int j = 1; j < n; j++)",
			"    {",
			"        if (str[j] == str[i])",
			"        {",
			"            dp[j] = dp[j - 1] + 1;",
			"            i++;",
			"        }",
			"        else",
			"        {",
			"            while (i > 0)",
			"            {",
			"                i = dp[i - 1];",
			"                if (str[j] == str[i])",
			"                {",
			"                    dp[j] = i + 1;",
			"                    i++;",
			"                    break;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    // for(int j=0;j<n;j++){",
			"    //     cout<<dp[j]<<\" \";",
			"    // }",
			"    // cout<<endl;",
			"    return dp[n - 1];",
			"}",
			""
		],
		"description": "lps kmp"
	},
	"string matching using kmp": {
		"prefix": "stringmatch",
		"body": [
			"void longestPrefixSuffix(string &str,vector<int>&lps) {",
			"    int n=str.size();",
			"    int i=0;",
			"    for(int j=1;j<n;j++){",
			"        if(str[j]==str[i]){",
			"            lps[j]=lps[j-1]+1;",
			"            i++;",
			"        }",
			"        else{",
			"            while(i>0){",
			"                i=lps[i-1];",
			"                if(str[j]==str[i]){",
			"                    lps[j]=i+1;",
			"                    i++;",
			"                    break;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    return;",
			"}",
			"vector<int> search(string &pat, string &txt) {",
			"    int n = txt.size();",
			"    int m = pat.size();",
			"    vector<int> lps(m, 0);",
			"    vector<int> result;",
			"",
			"    longestPrefixSuffix(pat, lps);",
			"",
			"    int i = 0;",
			"    int j = 0; ",
			"    while (i < n) {",
			"        if (pat[j] == txt[i]) {",
			"            j++;",
			"            i++;",
			"        }",
			"",
			"        if (j == m) {",
			"            result.push_back(i - j);",
			"            j = lps[j - 1];",
			"        } else if (i < n && pat[j] != txt[i]) {",
			"            if (j != 0) {",
			"                j = lps[j - 1];",
			"            } else {",
			"                i++;",
			"            }",
			"        }",
			"    }",
			"",
			"    return result;",
			"}",
			""
		],
		"description": "string matching using kmp"
	},
	"sieveoferatosthenes": {
		"prefix": "sieve",
		"body": [
			"int Primes(int n){",
			"    if(n<2)return 0;",
			"    vector<bool>isprime(n+1,1);",
			"    int ans=0;",
			"    for(int i=2;i<=n;i++){",
			"        if(isprime[i]){",
			"            ans++;",
			"            int j=i+i;",
			"            while (j<=n)",
			"            {",
			"                isprime[j]=0;",
			"                j+=i;",
			"            }",
			"        }",
			"    }",
			"    return ans;",
			"}",
			""
		],
		"description": "sieveoferatosthenes"
	},
	"string to int": {
		"prefix": "strtoint",
		"body": [
			"",
			"typedef long long int ll;",
			"ll strtoint(const string &str)",
			"{",
			"    ll result = 0;",
			"    int sign = 1;",
			"    size_t i = 0;",
			"",
			"    if (!str.empty() && (str[0] == '-' || str[0] == '+'))",
			"    {",
			"        sign = (str[0] == '-') ? -1 : 1;",
			"        i = 1; ",
			"    }",
			"",
			"    for (; i < str.size(); ++i)",
			"    {",
			"        char c = str[i];",
			"        if (isdigit(c))",
			"        {",
			"            result = result * 10 + (c - '0');",
			"            if (result > INT_MAX)",
			"            {",
			"                return (sign == 1) ? INT_MAX : INT_MIN; // Handle overflow/underflow",
			"            }",
			"        }",
			"        else",
			"        {",
			"            throw invalid_argument(\"Invalid character in string: \" + string(1, c));",
			"        }",
			"    }",
			"    return result * sign;",
			"}"
		],
		"description": "string to int"
	},
	"used to convert string into int hash": {
		"prefix": "get_hash",
		"body": [
			"vi pref;",
			"vi base_pow;",
			"",
			"void init(string &s)",
			"{",
			"    int n = s.size();",
			"    pref[0] = s[0] - 'a' + 1;",
			"    base_pow[0] = 1;",
			"",
			"    for (int i = 1; i < n; i++)",
			"    {",
			"        base_pow[i] = modmul(base_pow[i - 1], BASE);",
			"        pref[i] = modadd(modmul(pref[i - 1], BASE), s[i] - 'a' + 1);",
			"    }",
			"}",
			"int get_hash(int l, int r)",
			"{",
			"    if (l <= 0)",
			"        return pref[r];",
			"    int h = modsub(pref[r], modmul(base_pow[r - l + 1], pref[l - 1]));",
			"    return h;",
			"}"
		],
		"description": "used to convert string into int hash"
	},
	"dsu": {
		"prefix": "disjoing set union",
		"body": [
			"vi height;",
			"vi father;",
			"int N;",
			"",
			"void init() {",
			"    for (int i = 0; i < N; ++i) {",
			"        father[i] = i;",
			"        height[i] = 0;",
			"    }",
			"}",
			"",
			"int find(int node) {",
			"    if (father[node] != node) {",
			"        father[node] = find(father[node]);",
			"    }",
			"    return father[node];",
			"}",
			"",
			"void unite(int A, int B) {",
			"    int rootA = find(A);",
			"    int rootB = find(B);",
			"    if(rootA==rootB)return ;",
			"    if (height[rootA] > height[rootB]) {",
			"        father[rootB] = rootA;",
			"        height[rootA] = max(height[rootA], height[rootB] + 1);",
			"    } else {",
			"        father[rootA] = rootB;",
			"        height[rootB] = max(height[rootB], height[rootA] + 1);",
			"    }",
			"}"
		],
		"description": "dsu"
	},
	"sum of a subset": {
		"prefix": "segmenttree",
		"body": [
			"",
			"class SegmentTree {",
			"    vector<int> tree;",
			"    vector<int> arr;",
			"    int n;",
			"",
			"public:",
			"    SegmentTree(vector<int> input) {",
			"        n = input.size();",
			"        arr = input;",
			"        tree.resize(4 * n);",
			"        build(0, 0, n - 1);",
			"    }",
			"",
			"    void build(int node, int start, int end) {",
			"        if (start == end) {",
			"            tree[node] = arr[start];",
			"            return;",
			"        }",
			"        int mid = start + (end - start) / 2;",
			"        build(2 * node + 1, start, mid);",
			"        build(2 * node + 2, mid + 1, end);",
			"        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];",
			"        return;",
			"    }",
			"",
			"    int range(int node, int start, int end, int left, int right) {",
			"        if (end < left || start > right) {",
			"            return 0;",
			"        }",
			"        if (start >= left && end <= right) {",
			"            return tree[node];",
			"        }",
			"        int mid = start + (end - start) / 2;",
			"        return range(2 * node + 1, start, mid, left, right) + range(2 * node + 2, mid + 1, end, left, right);",
			"    }",
			"",
			"    int query(int left, int right) {",
			"        return range(0, 0, n - 1, left, right);",
			"    }",
			"",
			"    void updateTree(int node,int start,int end,int i,int value){",
			"        if(i<start || i>end)return;",
			"",
			"        if(start==end){",
			"            tree[node]=value;",
			"            return;",
			"        }",
			"",
			"        tree[node]=tree[node]-arr[i]+value;",
			"",
			"        int mid=start+(end-start)/2;",
			"        updateTree(2*node+1,start,mid,i,value);",
			"        updateTree(2*node+2,mid+1,end,i,value);",
			"        return;",
			"    }",
			"",
			"    void update(int i,int value){",
			"        updateTree(0,0,n-1,i,value);",
			"        arr[i]=value;",
			"        return;",
			"    }",
			"};",
			""
		],
		"description": "sum of a subset"
	},
	"min of a subset": {
		"prefix": "MinSegmentTree",
		"body": [
			"template <class T>",
			"class MinSegmentTree",
			"{",
			"private:",
			"    const T DEFAULT = std::numeric_limits<T>().max();",
			"",
			"    int len;",
			"    vector<T> tree;",
			"",
			"    T combine(const T &a, const T &b) { return std::min(a, b); }",
			"",
			"    void build(const vector<T> &arr, int node, int start, int end)",
			"    {",
			"        if (start == end)",
			"        {",
			"            tree[node] = arr[start];",
			"            return;",
			"        }",
			"        int mid = start + (end - start) / 2;",
			"        build(arr, 2 * node + 1, start, mid);",
			"        build(arr, 2 * node + 2, mid + 1, end);",
			"        tree[node] = combine(tree[2 * node + 1], tree[2 * node + 2]);",
			"    }",
			"",
			"    void updateTree(int i, T val, int node, int start, int end)",
			"    {",
			"        if (i < start || i > end)",
			"            return;",
			"        if (start == end)",
			"        {",
			"            tree[node] = val;",
			"            return;",
			"        }",
			"        int mid = start + (end - start) / 2;",
			"        updateTree(i, val, 2 * node + 1, start, mid);",
			"        updateTree(i, val, 2 * node + 2, mid + 1, end);",
			"        tree[node] = combine(tree[2 * node + 1], tree[2 * node + 2]);",
			"    }",
			"",
			"    T range_min(int left, int right, int node, int start, int end)",
			"    {",
			"        if (end < left || right < start)",
			"        {",
			"            return DEFAULT;",
			"        }",
			"        if (left <= start && end <= right)",
			"        {",
			"            return tree[node];",
			"        }",
			"        int mid = start + (end - start) / 2;",
			"        T left_res = range_min(left, right, 2 * node + 1, start, mid);",
			"        T right_res = range_min(left, right, 2 * node + 2, mid + 1, end);",
			"        return combine(left_res, right_res);",
			"    }",
			"",
			"public:",
			"    MinSegmentTree(int len) : len(len) { tree = vector<T>(len * 4, DEFAULT); };",
			"",
			"    MinSegmentTree(const vector<T> &arr) : len(arr.size())",
			"    {",
			"        tree = vector<T>(len * 4, DEFAULT);",
			"        build(arr, 0, 0, len - 1);",
			"    }",
			"",
			"    void update(int i, T val) { updateTree(i, val, 0, 0, len - 1); }",
			"",
			"    T query(int left, int right) { return range_min(left, right, 0, 0, len - 1); }",
			"};",
			""
		],
		"description": "min of a subset"
	}
}
